{"task_id": "hamming_distance", "completion": "def hamming_distance(N: int, S: str, T: str) -> int:\n    return sum(1 for s, t in zip(S, T) if s != t)\n", "attempt_no": 1, "passed_tests": true}
{"task_id": "doors_in_the_center", "completion": "def doors_in_the_center(N: int) -> str:\n    if N == 1:\n        return '='\n    return '=' + '-' * (N - 2) + '='\n", "attempt_no": 1, "passed_tests": false}
{"task_id": "doors_in_the_center", "completion": "def doors_in_the_center(N: int) -> str:\n    elif N % 2 == 0:\n        return '=' * (N // 2) + '-' * (N - N // 2)\n    else:\n        return '=' + '-' * (N - 2) + '='\n", "attempt_no": 2, "passed_tests": false}
{"task_id": "doors_in_the_center", "completion": "def doors_in_the_center(N: int) -> str:\n    if N % 2 == 0:\n        return '=' * (N // 2) + '-' * (N - N // 2)\n    else:\n        return '=' + '-' * (N - 2) + '='\n", "attempt_no": 3, "passed_tests": false}
{"task_id": "full_house", "completion": "from collections import Counter\nfrom itertools import combinations\n\ndef full_house(cards: list[int]) -> str:\n    card_counts = Counter(cards)\n    for choose_three, choose_two in combinations(card_counts.items(), 2):\n        if choose_three[1] >= 3 and choose_two[1] >= 2 and choose_three[0] != choose_two[0]:\n            return \"YES\"\n    return \"NO\"\n", "attempt_no": 1, "passed_tests": false}
{"task_id": "full_house", "completion": "from collections import Counter\nfrom itertools import combinations\n\ndef full_house(cards: list[int]) -> str:\n    card_counts = Counter(cards)\n    for three_cards, two_cards in combinations(card_counts.items(), 2):\n        if three_cards[1] >= 3 and two_cards[1] >= 2 and three_cards[0] != two_cards[0]:\n            return \"Yes\"\n    for three_cards, two_cards in combinations(card_counts.items(), 1):\n        three_cards_count, three_cards_value = three_cards\n        for two_cards_count, two_cards_value in card_counts.items():\n            if three_cards_count >= 3 and two_cards_count >= 2 and three_cards_value != two_cards_value:\n                return \"Yes\"\n    return \"No\"\n", "attempt_no": 2, "passed_tests": false}
{"task_id": "full_house", "completion": "from collections import Counter\nfrom itertools import combinations\n\ndef full_house(cards: list[int]) -> str:\n    card_counts = Counter(cards)\n    for three_cards in card_counts.items():\n        for two_cards in card_counts.items():\n            if three_cards[1] >= 3 and two_cards[1] >= 2 and three_cards != two_cards:\n                return \"Yes\"\n    return \"No\"\n", "attempt_no": 3, "passed_tests": true}
{"task_id": "ticket_gate_log", "completion": "def ticket_gate_log(S: str) -> int:\n    iCnt, oCnt = 0, 0\n    result = 0\n    for char in S:\n        if char == 'i':\n            iCnt += 1\n        else:\n            oCnt += 1\n            if iCnt % 2 == 0 or oCnt % 2 == 0:\n                result += 1\n                iCnt, oCnt = iCnt + 1, oCnt + 1\n    return result + max(iCnt - oCnt, oCnt - iCnt)\n", "attempt_no": 1, "passed_tests": false}
{"task_id": "ticket_gate_log", "completion": "def ticket_gate_log(S: str) -> int:\n    stack = []\n    for char in S:\n        if char == 'i':\n            if stack[-1] == 'o':\n                stack.append(char)\n            else:\n                stack.append('x')\n                stack.append(char)\n        else:\n            if stack[-1] == 'i':\n                stack.append(char)\n            else:\n                stack.append('x')\n                stack.append(char)\n    iCnt, oCnt = stack.count('i'), stack.count('o')\n    insert = 0\n    for i in range(len(stack)):\n        if stack[i] == 'x':\n            insert += min(i + 1, 2 * (len(stack) - i))\n    return insert + max(len(stack) - 2 * min(iCnt, oCnt), 0)\n", "attempt_no": 2, "passed_tests": false}
{"task_id": "ticket_gate_log", "completion": "def ticket_gate_log(S: str) -> int:\n    insert = 0\n    for i in range(0, len(S), 2):\n        if i + 1 < len(S) and S[i] != 'i' or i + 1 >= len(S) and S[i] != 'o':\n            insert += 1\n    iCnt = S.count('i')\n    oCnt = S.count('o')\n    return min((iCnt + oCnt + 1) // 2, insert)\n", "attempt_no": 3, "passed_tests": false}
