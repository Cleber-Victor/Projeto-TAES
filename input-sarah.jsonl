{"task_id": "HumanEval/coin_piles_extended", "entry_point": "can_empty_piles", "prompt": "def can_empty_piles(a: int, b: int) -> bool:\n    \"\"\"\n    You have two coin piles containing a and b coins. On each move, you can either:\n    - remove one coin from the left pile and two coins from the right pile, or\n    - remove two coins from the left pile and one coin from the right pile.\n    \n    Your task is to efficiently find out if you can empty both the piles.\n    Return True if it is possible to empty both piles, False otherwise.\n    \"\"\"\n", "canonical_solution": "def can_empty_piles(a: int, b: int) -> bool:\n    aux1 = 2 * a - b\n    aux2 = 2 * b - a\n    return aux1 >= 0 and aux2 >= 0 and aux1 % 3 == 0 and aux2 % 3 == 0", "test": "def check(candidate):\n    assert candidate(288, 440) == False\n    assert candidate(194, 290) == False\n    assert candidate(101, 189) == False\n    assert candidate(17, 431) == False\n    assert candidate(117, 203) == False\n    assert candidate(65, 404) == False\n"}
{"task_id": "HumanEval/collatz_sequence", "entry_point": "collatz_sequence", "prompt": "def collatz_sequence(n: int) -> str:\n    \"\"\"\n    Consider an algorithm that takes as input a positive integer n. If n is even, it is divided by two;\n    if n is odd, it is multiplied by three and increased by one. This process repeats until n becomes 1.\n    Return a space-separated string of the values of n during the algorithm.\n    \"\"\"\n", "canonical_solution": "def collatz_sequence(n: int) -> str:\n    result = [str(n)]\n    while n != 1:\n        n = n // 2 if n % 2 == 0 else 3 * n + 1\n        result.append(str(n))\n    return ' '.join(result)", "test": "def check(candidate):\n    assert candidate(1) == \"1\"\n    assert candidate(7) == \"7 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1\"\n"}
{"task_id": "HumanEval/max_movies", "entry_point": "max_movies", "prompt": "def max_movies(movies: list[tuple[int, int]]) -> int:\n    \"\"\"\n    In a movie festival, each movie has a start and end time.\n    You can only watch a movie if you watch it entirely, and cannot overlap with another.\n    Return the maximum number of movies you can watch.\n    \"\"\"\n", "canonical_solution": "def max_movies(movies: list[tuple[int, int]]) -> int:\n    movies.sort(key=lambda x: x[1])\n    count = 0\n    current_end = 0\n    for start, end in movies:\n        if start >= current_end:\n            current_end = end\n            count += 1\n    return count", "test": "def check(candidate):\n    assert candidate([(1, 1000), (2, 3), (5, 6)]) == 2\n    assert candidate([(6, 7), (4, 5), (8, 9), (2, 3), (10, 11), (1, 2), (9, 10), (3, 4), (5, 6), (7, 8)]) == 10\n"}
{"task_id": "HumanEval/smallest_unmakeable_sum", "entry_point": "smallest_unmakeable_sum", "prompt": "def smallest_unmakeable_sum(coins: list[int]) -> int:\n    \"\"\"\n    You have n coins with positive integer values.\n    Return the smallest sum you cannot create using a subset of the coins.\n    \"\"\"\n", "canonical_solution": "def smallest_unmakeable_sum(coins: list[int]) -> int:\n    coins.sort()\n    ans = 1\n    for coin in coins:\n        if coin > ans:\n            break\n        ans += coin\n    return ans", "test": "def check(candidate):\n    assert candidate([2, 9, 1, 2, 7]) == 6\n"}