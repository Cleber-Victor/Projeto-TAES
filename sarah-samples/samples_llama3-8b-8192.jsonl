{"task_id": "HumanEval/coin_piles_extended", "completion": "def can_empty_piles(a: int, b: int) -> bool:\n    while a > 0 and b > 0:\n        if a > 2 and b >= 3:\n            a -= 1\n            b -= 2\n        elif a >= 3 and b > 2:\n            a -= 2\n            b -= 1\n        elif a % 3 >= 1 and b % 2 == 0:\n            a -= 1\n            b -= 2\n        elif a % 2 == 0 and b % 3 >= 1:\n            a -= 2\n            b -= 1\n        else:\n            return False\n    return True", "attempt_no": 1, "passed_tests": false}
{"task_id": "HumanEval/coin_piles_extended", "completion": "def can_empty_piles(a: int, b: int) -> bool:\n    while a > 0 and b > 0:\n        if a >= 2 and b >= 3:\n            a -= 2\n            b -= 3\n        elif a >= 3 and b >= 2:\n            a -= 3\n            b -= 2\n        else:\n            return False\n    return True", "attempt_no": 2, "passed_tests": false}
{"task_id": "HumanEval/coin_piles_extended", "completion": "def can_empty_piles(a: int, b: int) -> bool:\n    return (a + b) % 3 == 0", "attempt_no": 3, "passed_tests": true}
{"task_id": "HumanEval/collatz_sequence", "completion": "\" \".join(map(str, reduce(lambda x, _: [x] + (x//2, x*3+1)[x%2] if x!=1 else [], int(input()), accumulate)))", "attempt_no": 1, "passed_tests": false}
{"task_id": "HumanEval/collatz_sequence", "completion": "from itertools import accumulate\n\ndef collatz_sequence(n):\n    sequence = [n]\n    while n != 1:\n        n = n // 2 if n % 2 == 0 else n * 3 + 1\n        sequence.append(n)\n    return ' '.join(map(str, sequence))\n", "attempt_no": 2, "passed_tests": true}
{"task_id": "HumanEval/max_movies", "completion": "def max_movies(movies: list[tuple[int, int]]) -> int:\n    movies.sort()\n    end = movies[0][1]\n    count = 1\n    for i in range(1, len(movies)):\n        if movies[i][0] >= end:\n            end = movies[i][1]\n            count += 1\n    return count", "attempt_no": 1, "passed_tests": false}
{"task_id": "HumanEval/max_movies", "completion": "def max_movies(movies: list[tuple[int, int]]) -> int:\n    movies.sort()\n    end = movies[0][1]\n    count = 1\n    for i in range(1, len(movies)):\n        if movies[i][0] >= end:\n            end = movies[i][1]\n            count += 1\n    return count\n", "attempt_no": 2, "passed_tests": false}
{"task_id": "HumanEval/max_movies", "completion": "def max_movies(movies: list[tuple[int, int]]) -> int:\n    movies.sort(key=lambda x: x[1])\n    end_time = movies[0][1]\n    count = 1\n    for i in range(1, len(movies)):\n        if movies[i][0] >= end_time:\n            end_time = movies[i][1]\n            count += 1\n    return count", "attempt_no": 3, "passed_tests": true}
{"task_id": "HumanEval/smallest_unmakeable_sum", "completion": "def smallest_unmakeable_sum(coins):\n    max_sum = sum(coins)\n    coins.sort()\n    min_sum = 0\n    while True:\n        if min_sum + len([coin for coin in coins if coin <= min_sum]) > max_sum:\n            return min_sum\n        min_sum += 1", "attempt_no": 1, "passed_tests": false}
{"task_id": "HumanEval/smallest_unmakeable_sum", "completion": "def smallest_unmakeable_sum(coins):\n    coins.sort()\n    target = 1\n    while True:\n        total = 0\n        for coin in coins:\n            total += coin // target\n        if total < target:\n            return target - 1\n        target += 1", "attempt_no": 2, "passed_tests": false}
{"task_id": "HumanEval/smallest_unmakeable_sum", "completion": "def smallest_unmakeable_sum(coins):\n    coins.sort()\n    target = coins[0]\n    while True:\n        if sum(coin // target for coin in coins) >= target:\n            target += 1\n        else:\n            return target - 1", "attempt_no": 3, "passed_tests": false}
